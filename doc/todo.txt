
数组拼接的优化
value.joinToString(", ", "(", ")") {
    quote(it)
}

----------

问题：
oracle中查询用户表，却select未知的字段

解决：
在database.yaml中添加一个配置项schema
    # 在 Db.tableColumns 中延迟加载表字段时，用来过滤 DYPT 库的表，仅在oracle中有用
    schema: DYPT

在 Db.tableColumns 中使用schema 来过滤表与字段
/**
 * fix bug:
 * mysql中查询，conn.catalog = 数据库名
 * oracle中查询，conn.catalog = null，必须指定 dbConfig["schema"] 来过滤表，否则查出来多个库的表，会出现同名表，查出来的表字段有误
 */
val rs = conn.metaData.getColumns(conn.catalog, dbConfig["schema"], null, null)


--------

bug：

java 数据库查询Date类型字段 没有了时分秒 全为 00


分析：
https://www.cnblogs.com/lidabo/archive/2013/03/08/2950107.html
http://www.blogjava.net/midea0978/archive/2008/06/13/207655.html

原因：
odbc中对Date类型字段的处理，转为java.sql.Date，只保留日期，丢掉时分秒


解决：
添加连接属性：oracle.jdbc.V8Compatible=true

vim database.yaml

# 强制odbc使用旧的类型映射，将Date类型字段，转为java.sql.Timestamp，保留日期+时分秒
connectionProperties: oracle.jdbc.V8Compatible=true


--------

字段做映射，应该缓存

orm的主键类型可以自定义

---------

com.jkmvc.db.DruidDataSourceFactory
适配oracle有问题
=> dataSourceFactory 可配置，系统创建实例
/**
 * hsqldb - "select 1 from INFORMATION_SCHEMA.SYSTEM_USERS"
 * Oracle - "select 1 from dual"
 * DB2 - "select 1 from sysibm.sysdummy1"
 * mysql - "select 1"
 */
ds.setValidationQuery(config.get("validationQuery", "select 1 from dual"))

---------

优化quote()性能

问题
各种quote()涉及到字符串运算，如转义表从 user 变为 `user`
如果调用频繁， 则会创建大量的临时字符串，大量消耗内存与cpu

解决
quote()都是落在Db，在db对象中建一个quote前quote后的字符串映射的map

---------

转义表有问题
mysql是`` orable是""
先暂时去掉
    /**
     * 转义表名
     *
     * @param table
     * @param alias 表别名
     * @return
     */
    public override fun quoteTable(table:String, alias:String?):String
    {
        val s = ""
        return if(alias == null)
            "$s$table$s";
        else
            "$s$table$s  AS `$alias`"
    }

---------

判断数据库类型
/**
 * 判断数据库类型
 * @return
 * @throws SQLException
 */
        public String getDataBaseType() throws SQLException {
            //通过driverName是否包含关键字判断
            if (connection.getMetaData().getDriverName().toUpperCase()
                    .indexOf("MYSQL") != -1) {
                return "MySql";
            } else if (connection.getMetaData().getDriverName().toUpperCase()
                    .indexOf("SQL SERVER") != -1) {
                //sqljdbc与sqljdbc4不同，sqlserver中间有空格
                return "SqlServer";
            }
            return "-1";
        }

---------

orm主键不是int -- 改造完毕 -- 直接弄成any

orm querybuild中自动转换字段值，为了在各种action中适配各种值
    public override fun andWhere(column: String, op: String, value: Any?): IDbQueryBuilder {
        // 智能转换字段值
        val realValue = if(intelligent && value is String)
                            ormMeta.convertIntelligent(column, value)
                        else
                            value
        // 转换字段名
        val realColumn = ormMeta.prop2Column(column)
        return super.andWhere(realColumn, op, value)
    }

另外在action的元数据 renderMeta 中要指定query builder为智能模式：自动转换字段值
    /**
     * 获得orm查询构建器
     */
    public fun queryBuilder(): OrmQueryBuilder {
        return model.modelOrmMeta.queryBuilder(true /* 查询时智能转换字段值 */).wheres(conditions) as OrmQueryBuilder
    }

对分页处理，由于oracle不支持limit语法，因此直接内存分页

常见的oracle sql
http://www.cnblogs.com/wishyouhappy/p/3700683.html

todo: query build 的limit() 支持oracle


----------

智能判断是否包含关系

/**
 * 是否有某个关联关系
 *
 * @param name 字段名，类型可以是 1 String 本模型字段名 2 Pair<String, List<String>> 关系名 + 关联模型的字段列表
 * @return
 */
fun hasRelation(name: Any):Boolean{
    return when(name){
        is Pair<*, *> -> hasRelation(name.first as String) // 多层关系
        is String -> hasRelation(name)  // 单层关系
        else -> throw IllegalArgumentException("查询字段参数类型必须是：1 String 本模型字段名 2 Pair<String, List<String>> 关系名 + 关联模型的字段列表")
    }
}

---------



代码启动jetty

    // jetty
    compile "org.eclipse.jetty.aggregate:jetty-all:${jetty_version}"
//    compile "org.eclipse.jetty:jetty-server:${jetty_version}"
//    compile "org.eclipse.jetty:jetty-servlet:${jetty_version}"
//    compile "org.eclipse.jetty:jetty-webapp:${jetty_version}"
//    compile "org.eclipse.jetty:jetty-servlets:${jetty_version}"



package com.jkmvc.szpower

import org.eclipse.jetty.server.Server
import org.eclipse.jetty.webapp.*

fun main(args: Array<String>) {
    val server = Server(8080);

    val context = WebAppContext();
  context.setDescriptor("/oldhome/shi/code/java/szpower/szpower/jkmvc-szpower/src/main/webapp/WEB-INF/web.xml");
    context.setResourceBase("/oldhome/shi/code/java/szpower/szpower/jkmvc-szpower/src/main/webapp");
    context.setContextPath("/");
    context.setParentLoaderPriority(true);
    server.setHandler(context);

    println("start server in 8080")
    server.start();
    server.join();
}

---------------

query builder支持子查询？

### 6.4 Subqueries

Query Builder objects can be passed as parameters to many of the methods to create subqueries. Let"s take the previous example query and pass it to a new query.

    $sub = DB::select("username", array(DB::expr("COUNT(`id`)"), "total_posts")
        .from("posts").group_by("username").having("total_posts", ">=", 10);

    $query = DB::select("profiles.*", "posts.total_posts").from("profiles")
        .join(array($sub, "posts"), "INNER").on("profiles.username", "=", "posts.username");

This will generate the following query:

    SELECT `profiles`.*, `posts`.`total_posts` FROM `profiles` INNER JOIN
    ( SELECT `username`, COUNT(`id`) AS `total_posts` FROM `posts` GROUP BY `username` HAVING `total_posts` >= 10 ) AS posts
    ON `profiles`.`username` = `posts`.`username`

Insert queries can also use a select query for the input values

    $sub = DB::select("username", array(DB::expr("COUNT(`id`)"), "total_posts")
        .from("posts").group_by("username").having("total_posts", ">=", 10);

    $query = DB::insert("post_totals", array("username", "posts")).select($sub);

This will generate the following query:

    INSERT INTO `post_totals` (`username`, `posts`)
    SELECT `username`, COUNT(`id`) AS `total_posts` FROM `posts` GROUP BY `username` HAVING `total_posts` >= 10

--------

orm的关联查询支持, 跨库的关联表

-------

query builder中如果in参数超过1000个，则拆分

目前是放在query builder层去拆分，一个list会拆成多个子list，性能差点
好的应该放在valueQuoter，来使用字符串拼接的方式来做，性能好
    /**
     * 转义值
     */
    protected val valueQuoter: (Any?) -> String = { value: Any? ->
        quote(value);
    }

-------

优化命名

搜索 Pair< 来重命名类型

如路由参数
typealias RouteParams = Pair<String, String>

如表/字段别名
table:Pair<String, String?>
typealias NameAlias = Pair<String, String?>

如修饰子句中 DbQueryBuilderDecoration
: DbQueryBuilderDecorationClauses<Pair<Array<Any?>, String>>/* subexps 是子表达式+连接符(针对where子句，放子表达式前面) */
typealias ValAndOpr = Pair<Array<Any?>, String>

protected var limitParams:Pair<Int, Int>? = null

如 SelectColumnList 中
Pair<String, SelectColumnList?>


------

将函数调用封装为lambda -- 简化封装

如 { value: Any? -> quote(value) } 可简化为 this::quote
可通过 '对象::函数' 来引用

-----


优化从resultset中获得指定类型的数据

参考spring api
List<T> list =  this.jdbcTemplate.query(sql, new BeanPropertyRowMapper<T>(clazz), args);

其中 BeanPropertyRowMapper.mapRow() 是从resultset中获得指定类型的属性（通过反射获得目标类的属性的类型）

	/**
	 * Extract the values for all columns in the current row.
	 * <p>Utilizes public setters and result set metadata.
	 * @see java.sql.ResultSetMetaData
	 */
	@Override
	public T mapRow(ResultSet rs, int rowNumber) throws SQLException {
		Assert.state(this.mappedClass != null, "Mapped class was not specified");
		T mappedObject = BeanUtils.instantiate(this.mappedClass);
		BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(mappedObject);
		initBeanWrapper(bw);

		ResultSetMetaData rsmd = rs.getMetaData();
		int columnCount = rsmd.getColumnCount();
		Set<String> populatedProperties = (isCheckFullyPopulated() ? new HashSet<String>() : null);

		for (int index = 1; index <= columnCount; index++) {
			String column = JdbcUtils.lookupColumnName(rsmd, index);
			String field = lowerCaseName(column.replaceAll(" ", ""));
			PropertyDescriptor pd = this.mappedFields.get(field);
			if (pd != null) {
				try {
					Object value = getColumnValue(rs, index, pd);
					if (rowNumber == 0 && logger.isDebugEnabled()) {
						logger.debug("Mapping column '" + column + "' to property '" + pd.getName() +
								"' of type [" + ClassUtils.getQualifiedName(pd.getPropertyType()) + "]");
					}
					try {
						bw.setPropertyValue(pd.getName(), value);
					}
					catch (TypeMismatchException ex) {
						if (value == null && this.primitivesDefaultedForNullValue) {
							if (logger.isDebugEnabled()) {
								logger.debug("Intercepted TypeMismatchException for row " + rowNumber +
										" and column '" + column + "' with null value when setting property '" +
										pd.getName() + "' of type [" +
										ClassUtils.getQualifiedName(pd.getPropertyType()) +
										"] on object: " + mappedObject, ex);
							}
						}
						else {
							throw ex;
						}
					}
					if (populatedProperties != null) {
						populatedProperties.add(pd.getName());
					}
				}
				catch (NotWritablePropertyException ex) {
					throw new DataRetrievalFailureException(
							"Unable to map column '" + column + "' to property '" + pd.getName() + "'", ex);
				}
			}
			else {
				// No PropertyDescriptor found
				if (rowNumber == 0 && logger.isDebugEnabled()) {
					logger.debug("No property found for column '" + column + "' mapped to field '" + field + "'");
				}
			}
		}

		if (populatedProperties != null && !populatedProperties.equals(this.mappedProperties)) {
			throw new InvalidDataAccessApiUsageException("Given ResultSet does not contain all fields " +
					"necessary to populate object of class [" + this.mappedClass.getName() + "]: " +
					this.mappedProperties);
		}

		return mappedObject;
	}



	/**
	 * Retrieve a JDBC column value from a ResultSet, using the specified value type.
	 * <p>Uses the specifically typed ResultSet accessor methods, falling back to
	 * {@link #getResultSetValue(java.sql.ResultSet, int)} for unknown types.
	 * <p>Note that the returned value may not be assignable to the specified
	 * required type, in case of an unknown type. Calling code needs to deal
	 * with this case appropriately, e.g. throwing a corresponding exception.
	 * @param rs is the ResultSet holding the data
	 * @param index is the column index
	 * @param requiredType the required value type (may be {@code null})
	 * @return the value object
	 * @throws SQLException if thrown by the JDBC API
	 */
	@UsesJava7  // guard optional use of JDBC 4.1 (safe with 1.6 due to getObjectWithTypeAvailable check)
	public static Object getResultSetValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException {
		if (requiredType == null) {
			return getResultSetValue(rs, index);
		}

		Object value;

		// Explicitly extract typed value, as far as possible.
		if (String.class == requiredType) {
			return rs.getString(index);
		}
		else if (boolean.class == requiredType || Boolean.class == requiredType) {
			value = rs.getBoolean(index);
		}
		else if (byte.class == requiredType || Byte.class == requiredType) {
			value = rs.getByte(index);
		}
		else if (short.class == requiredType || Short.class == requiredType) {
			value = rs.getShort(index);
		}
		else if (int.class == requiredType || Integer.class == requiredType) {
			value = rs.getInt(index);
		}
		else if (long.class == requiredType || Long.class == requiredType) {
			value = rs.getLong(index);
		}
		else if (float.class == requiredType || Float.class == requiredType) {
			value = rs.getFloat(index);
		}
		else if (double.class == requiredType || Double.class == requiredType ||
				Number.class == requiredType) {
			value = rs.getDouble(index);
		}
		else if (BigDecimal.class == requiredType) {
			return rs.getBigDecimal(index);
		}
		else if (java.sql.Date.class == requiredType) {
			return rs.getDate(index);
		}
		else if (java.sql.Time.class == requiredType) {
			return rs.getTime(index);
		}
		else if (java.sql.Timestamp.class == requiredType || java.util.Date.class == requiredType) {
			return rs.getTimestamp(index);
		}
		else if (byte[].class == requiredType) {
			return rs.getBytes(index);
		}
		else if (Blob.class == requiredType) {
			return rs.getBlob(index);
		}
		else if (Clob.class == requiredType) {
			return rs.getClob(index);
		}
		else {
			// Some unknown type desired -> rely on getObject.
			if (getObjectWithTypeAvailable) {
				try {
					return rs.getObject(index, requiredType);
				}
				catch (AbstractMethodError err) {
					logger.debug("JDBC driver does not implement JDBC 4.1 'getObject(int, Class)' method", err);
				}
				catch (SQLFeatureNotSupportedException ex) {
					logger.debug("JDBC driver does not support JDBC 4.1 'getObject(int, Class)' method", ex);
				}
				catch (SQLException ex) {
					logger.debug("JDBC driver has limited support for JDBC 4.1 'getObject(int, Class)' method", ex);
				}
			}
			// Fall back to getObject without type specification...
			return getResultSetValue(rs, index);
		}

		// Perform was-null check if necessary (for results that the JDBC driver returns as primitives).
		return (rs.wasNull() ? null : value);
	}


其实，可以根据类型来抽取出要调用的 resultset 的方法


----------

优化： 读取Blob/Clob字段

用 blob.getBytes(1, (int) blob.length()); 替换
/**
 * Blob转ByteArray
 * @return
 */
public fun Blob?.toByteArray(): ByteArray? {
    if (this == null || binaryStream == null)
        return null

    return binaryStream.use {
        val data = ByteArray(this.length().toInt())        // byte[] data = new byte[is.available()];
        if (data.size == 0)
            return null
        it.read(data)
        data
    }
}

用 clob.getSubString(1, (int) clob.length()); 替换

/**
 * Clob转String
 * @return
 */
public fun Clob?.toString2(): String? {
    if (this == null || characterStream == null)
        return null

    return characterStream.use {
        val buffer = CharArray(this.length().toInt())
        if (buffer.size == 0)
            return null
        it.read(buffer)
        String(buffer)
    }
}

--------------

改进的雪花id
原来: 时间戳 + 机器码 + 随机码(n位)
改进的: 时间戳 + 机器码 + 线程码 + 微妙内自增(如果并发高处理快, 单线程中1ms可处理2个请求的话)

---------------


去掉 Db.toLong

Db.toInt

? 改为  DbExpr.question


封装查询单个值的结果
Cell<T> 替换 Pair<Boolean, T?>


dbexpr 文档
cell


convertValue(prop)
支持DbExpr + DbKey

orm的构造函数, 支持复合主键 + 单元测试 + 文档


------------------

去掉 KClass<T>.recordTranformer

行参数类型为不可变map
将 transform: (MutableMap 替换为 transform: (Map

record 变量, 改名为row

Map<String, Any?> 类, 别名为 Row


findAll<Record> 改为 findAllRows
findAll< 改为 findAllModels<

find<Record> 改为 findRow
find< 改为 findModel<


反射的findxxx()方法, 改名为getxxx(), 与java的Class类一致

------------

完善校验器

修改api, 不再返回那么多值
直接返回结果, 如果有错, 则直接抛异常

另外封装一个只有一个validate()方法的接口, 可以让开发者自己写lambda来校验

